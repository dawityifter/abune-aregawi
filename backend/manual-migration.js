require('dotenv').config();
const { Pool } = require('pg');

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

async function manualMigration() {
  try {
    console.log('🔄 Starting manual database refactor from UUID to BIGINT...');

    // Step 0: Clean up any existing _new tables
    console.log('🧹 Cleaning up any existing _new tables...');
    await pool.query('DROP TABLE IF EXISTS transactions_new CASCADE');
    await pool.query('DROP TABLE IF EXISTS dependents_new CASCADE');
    await pool.query('DROP TABLE IF EXISTS members_new CASCADE');
    console.log('✅ Cleanup completed');

    // Step 1: Create new tables with BIGINT structure
    console.log('📋 Creating new members table with BIGINT...');
    await pool.query(`
      CREATE TABLE members_new (
        id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        firebase_uid VARCHAR(255) UNIQUE,
        first_name VARCHAR(100) NOT NULL,
        middle_name VARCHAR(100),
        last_name VARCHAR(100) NOT NULL,
        email VARCHAR(255) UNIQUE,
        phone_number VARCHAR(20) NOT NULL UNIQUE,
        date_of_birth DATE,
        gender VARCHAR(10),
        baptism_name VARCHAR(100),
        repentance_father VARCHAR(100),
        household_size INTEGER NOT NULL DEFAULT 1,
        street_line1 VARCHAR(255),
        apartment_no VARCHAR(50),
        city VARCHAR(100),
        state VARCHAR(50),
        postal_code VARCHAR(20),
        country VARCHAR(100) DEFAULT 'USA',
        emergency_contact_name VARCHAR(200),
        emergency_contact_phone VARCHAR(20),
        date_joined_parish DATE,
        spouse_name VARCHAR(200),
        family_id BIGINT REFERENCES members_new(id) ON UPDATE CASCADE ON DELETE SET NULL,
        role VARCHAR(20) NOT NULL DEFAULT 'member',
        is_active BOOLEAN NOT NULL DEFAULT true,
        registration_status VARCHAR(20) NOT NULL DEFAULT 'pending',
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);

    // Create indexes for members_new
    await pool.query('CREATE INDEX members_new_email_idx ON members_new(email)');
    await pool.query('CREATE INDEX members_new_phone_number_idx ON members_new(phone_number)');
    await pool.query('CREATE INDEX members_new_firebase_uid_idx ON members_new(firebase_uid)');
    await pool.query('CREATE INDEX members_new_role_idx ON members_new(role)');
    await pool.query('CREATE INDEX members_new_is_active_idx ON members_new(is_active)');
    await pool.query('CREATE INDEX members_new_family_id_idx ON members_new(family_id)');

    console.log('📋 Creating new dependents table with BIGINT...');
    await pool.query(`
      CREATE TABLE dependents_new (
        id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        member_id BIGINT NOT NULL REFERENCES members_new(id) ON UPDATE CASCADE ON DELETE CASCADE,
        first_name VARCHAR(100) NOT NULL,
        middle_name VARCHAR(100),
        last_name VARCHAR(100) NOT NULL,
        date_of_birth DATE,
        gender VARCHAR(10),
        relationship VARCHAR(100),
        medical_conditions TEXT,
        allergies TEXT,
        medications TEXT,
        dietary_restrictions TEXT,
        notes TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    `);

    await pool.query('CREATE INDEX dependents_new_member_id_idx ON dependents_new(member_id)');

    console.log('📋 Creating new transactions table with BIGINT...');
    await pool.query(`
      CREATE TABLE transactions_new (
        id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        member_id BIGINT NOT NULL REFERENCES members_new(id) ON UPDATE CASCADE ON DELETE RESTRICT,
        collected_by BIGINT NOT NULL REFERENCES members_new(id) ON UPDATE CASCADE ON DELETE RESTRICT,
        payment_date DATE NOT NULL DEFAULT CURRENT_DATE,
        amount DECIMAL(10,2) NOT NULL,
        payment_type VARCHAR(20) NOT NULL,
        payment_method VARCHAR(20) NOT NULL,
        receipt_number VARCHAR(100),
        note TEXT,
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
        CONSTRAINT check_receipt_for_cash_check CHECK (
          (payment_method IN ('cash', 'check') AND receipt_number IS NOT NULL) OR
          (payment_method NOT IN ('cash', 'check'))
        ),
        CONSTRAINT check_positive_amount CHECK (amount > 0)
      )
    `);

    await pool.query('CREATE INDEX transactions_new_member_id_idx ON transactions_new(member_id)');
    await pool.query('CREATE INDEX transactions_new_collected_by_idx ON transactions_new(collected_by)');
    await pool.query('CREATE INDEX transactions_new_payment_date_idx ON transactions_new(payment_date)');
    await pool.query('CREATE INDEX transactions_new_payment_type_idx ON transactions_new(payment_type)');
    await pool.query('CREATE INDEX transactions_new_payment_method_idx ON transactions_new(payment_method)');

    // Step 2: Migrate data from old tables to new tables
    console.log('🔄 Migrating data from old tables to new tables...');

    // Migrate members data
    console.log('📊 Migrating members data...');
    const members = await pool.query('SELECT * FROM members ORDER BY created_at');
    
    for (const member of members.rows) {
      // Convert gender to lowercase for enum compatibility
      const gender = member.gender ? member.gender.toLowerCase() : null;
      
      await pool.query(`
        INSERT INTO members_new (
          firebase_uid, first_name, middle_name, last_name, email, phone_number,
          date_of_birth, gender, baptism_name, repentance_father, household_size,
          street_line1, apartment_no, city, state, postal_code, country, 
          emergency_contact_name, emergency_contact_phone, date_joined_parish,
          spouse_name, role, is_active, registration_status, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26)
      `, [
        member.firebase_uid,
        member.first_name,
        member.middle_name,
        member.last_name,
        member.email,
        member.phone_number,
        member.date_of_birth,
        gender,
        member.baptism_name,
        member.repentance_father,
        member.household_size,
        member.street_line1,
        member.apartment_no,
        member.city,
        member.state,
        member.postal_code,
        member.country,
        member.emergency_contact_name,
        member.emergency_contact_phone,
        member.date_joined_parish,
        member.spouse_name,
        member.role,
        member.is_active,
        member.registration_status || 'pending',
        member.created_at,
        member.updated_at
      ]);
    }

    console.log(`✅ Migrated ${members.rows.length} members`);

    // Migrate dependants data
    console.log('📊 Migrating dependants data...');
    const dependants = await pool.query(`
      SELECT d.*, m.id as new_member_id 
      FROM dependants d 
      JOIN members m ON d.member_id = m.id 
      ORDER BY d.created_at
    `);

    for (const dependant of dependants.rows) {
      const gender = dependant.gender ? dependant.gender.toLowerCase() : null;
      
      await pool.query(`
        INSERT INTO dependents_new (
          member_id, first_name, middle_name, last_name, date_of_birth, gender,
          relationship, medical_conditions, allergies, medications, dietary_restrictions,
          notes, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      `, [
        dependant.new_member_id,
        dependant.first_name,
        dependant.middle_name,
        dependant.last_name,
        dependant.date_of_birth,
        gender,
        dependant.relationship,
        dependant.medical_conditions,
        dependant.allergies,
        dependant.medications,
        dependant.dietary_restrictions,
        dependant.notes,
        dependant.created_at,
        dependant.updated_at
      ]);
    }

    console.log(`✅ Migrated ${dependants.rows.length} dependants`);

    // Migrate church_transactions data
    console.log('📊 Migrating church_transactions data...');
    const transactions = await pool.query(`
      SELECT ct.*, m1.id as new_member_id, m2.id as new_collector_id 
      FROM church_transactions ct 
      JOIN members m1 ON ct.member_id = m1.id 
      JOIN members m2 ON ct.collected_by = m2.id 
      ORDER BY ct.created_at
    `);

    for (const transaction of transactions.rows) {
      await pool.query(`
        INSERT INTO transactions_new (
          member_id, collected_by, payment_date, amount, payment_type, payment_method,
          receipt_number, note, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      `, [
        transaction.new_member_id,
        transaction.new_collector_id,
        transaction.payment_date,
        transaction.amount,
        transaction.payment_type,
        transaction.payment_method,
        transaction.receipt_number,
        transaction.note,
        transaction.created_at,
        transaction.updated_at
      ]);
    }

    console.log(`✅ Migrated ${transactions.rows.length} transactions`);

    // Step 3: Update family_id references in members_new
    console.log('🔄 Updating family_id references...');
    const familyUpdates = await pool.query(`
      SELECT m1.id as old_id, m1.family_id as old_family_id, m2.id as new_family_id 
      FROM members m1 
      JOIN members m2 ON m1.family_id = m2.id 
      WHERE m1.family_id IS NOT NULL
    `);

    for (const update of familyUpdates.rows) {
      await pool.query(`
        UPDATE members_new SET family_id = $1 WHERE id = $2
      `, [update.new_family_id, update.old_id]);
    }

    console.log(`✅ Updated ${familyUpdates.rows.length} family references`);

    // Step 4: Drop old tables and rename new tables
    console.log('🗑️ Dropping old tables...');
    await pool.query('DROP TABLE IF EXISTS church_transactions CASCADE');
    await pool.query('DROP TABLE IF EXISTS dependants CASCADE');
    await pool.query('DROP TABLE IF EXISTS members CASCADE');

    console.log('🔄 Renaming new tables...');
    await pool.query('ALTER TABLE members_new RENAME TO members');
    await pool.query('ALTER TABLE dependents_new RENAME TO dependents');
    await pool.query('ALTER TABLE transactions_new RENAME TO transactions');

    console.log('✅ Migration completed successfully!');

    // Verify the migration
    console.log('🔍 Verifying migration...');
    const tables = await pool.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_name IN ('members', 'dependents', 'transactions')
      ORDER BY table_name
    `);

    console.log('Final tables:', tables.rows.map(row => row.table_name));

    const memberCount = await pool.query('SELECT COUNT(*) FROM members');
    const dependentCount = await pool.query('SELECT COUNT(*) FROM dependents');
    const transactionCount = await pool.query('SELECT COUNT(*) FROM transactions');

    console.log(`📊 Final counts: ${memberCount.rows[0].count} members, ${dependentCount.rows[0].count} dependents, ${transactionCount.rows[0].count} transactions`);

  } catch (error) {
    console.error('❌ Migration failed:', error);
    throw error;
  } finally {
    await pool.end();
  }
}

manualMigration().catch(console.error); 