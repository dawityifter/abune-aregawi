export const geezMap: { [key: string]: string } = {
    he: 'ሀ', hu: 'ሁ', hi: 'ሂ', ha: 'ሃ', hie: 'ሄ', h: 'ህ', ho: 'ሆ',
    le: 'ለ', lu: 'ሉ', li: 'ሊ', la: 'ላ', lie: 'ሌ', l: 'ል', lo: 'ሎ',
    He: 'ሐ', Hu: 'ሑ', Hi: 'ሒ', Ha: 'ሓ', Hie: 'ሔ', H: 'ሕ', Ho: 'ሖ',
    me: 'መ', mu: 'ሙ', mi: 'ሚ', ma: 'ማ', mie: 'ሜ', m: 'ም', mo: 'ሞ',
    se: 'ሰ', su: 'ሱ', si: 'ሲ', sa: 'ሳ', sie: 'ሴ', s: 'ስ', so: 'ሶ',
    re: 'ረ', ru: 'ሩ', ri: 'ሪ', ra: 'ራ', rie: 'ሬ', r: 'ር', ro: 'ሮ',
    qe: 'ቀ', qu: 'ቁ', qi: 'ቂ', qa: 'ቃ', qie: 'ቄ', q: 'ቅ', qo: 'ቆ',
    be: 'በ', bu: 'ቡ', bi: 'ቢ', ba: 'ባ', bie: 'ቤ', b: 'ብ', bo: 'ቦ',
    te: 'ተ', tu: 'ቱ', ti: 'ቲ', ta: 'ታ', tie: 'ቴ', t: 'ት', to: 'ቶ',
    che: 'ቸ', chu: 'ቹ', chi: 'ቺ', cha: 'ቻ', chie: 'ቼ', ch: 'ች', cho: 'ቾ',
    ne: 'ነ', nu: 'ኑ', ni: 'ኒ', na: 'ና', nie: 'ኔ', n: 'ን', no: 'ኖ',
    nye: 'ኘ', nyu: 'ኙ', nyi: 'ኚ', nya: 'ኛ', nyie: 'ኜ', ny: 'ኝ', nyo: 'ኞ',
    'e': 'አ', 'u': 'ኡ', 'i': 'ኢ', 'a': 'ኣ', 'ie': 'ኤ', 'ee': 'እ', 'o': 'ኦ',
    'E': 'ዐ', 'U': 'ዑ', 'I': 'ዒ', 'A': 'ዓ', 'IE': 'ዔ', 'EE': 'ዕ', 'O': 'ዖ',
    ke: 'ከ', ku: 'ኩ', ki: 'ኪ', ka: 'ካ', kie: 'ኬ', k: 'ክ', ko: 'ኮ',
    we: 'ወ', wu: 'ዉ', wi: 'ዊ', wa: 'ዋ', wie: 'ዌ', w: 'ው', wo: 'ዎ',
    ze: 'ዘ', zu: 'ዙ', zi: 'ዚ', za: 'ዛ', zie: 'ዜ', z: 'ዝ', zo: 'ዞ',
    Ze: 'ዠ', Zu: 'ዡ', Zi: 'ዢ', Za: 'ዣ', Zie: 'ዤ', Z: 'ዥ', Zo: 'ዦ',
    ye: 'የ', yu: 'ዩ', yi: 'ዪ', ya: 'ያ', yie: 'ዬ', y: 'ይ', yo: 'ዮ',
    de: 'ደ', du: 'ዱ', di: 'ዲ', da: 'ዳ', die: 'ዴ', d: 'ድ', do: 'ዶ',
    je: 'ጀ', ju: 'ጁ', ji: 'ጂ', ja: 'ጃ', jie: 'ጄ', j: 'ጅ', jo: 'ጆ',
    ge: 'ገ', gu: 'ጉ', gi: 'ጊ', ga: 'ጋ', gie: 'ጌ', g: 'ግ', go: 'ጎ',
    Te: 'ጠ', Tu: 'ጡ', Ti: 'ጢ', Ta: 'ጣ', Tie: 'ጤ', T: 'ጥ', To: 'ጦ',
    Ce: 'ጨ', Cu: 'ጩ', Ci: 'ጪ', Ca: 'ጫ', Cie: 'ጬ', C: 'ጭ', Co: 'ጮ',
    Pe: 'ጰ', Pu: 'ጱ', Pi: 'ጲ', Pa: 'ጳ', Pie: 'ጴ', P: 'ጵ', Po: 'ጶ',
    TSe: 'ጸ', TSu: 'ጹ', TSi: 'ጺ', TSa: 'ጻ', TSie: 'ጼ', TS: 'ጽ', TSo: 'ጾ',
    tse: 'ፀ', tsu: 'ፁ', tsi: 'ፂ', tsa: 'ፃ', tsie: 'ፄ', ts: 'ፅ', tso: 'ፆ',
    fe: 'ፈ', fu: 'ፉ', fi: 'ፊ', fa: 'ፋ', fie: 'ፌ', f: 'ፍ', fo: 'ፎ',
    pe: 'ፐ', pu: 'ፑ', pi: 'ፒ', pa: 'ፓ', pie: 'ፔ', p: 'ፕ', po: 'ፖ',
    ve: 'ቨ', vu: 'ቩ', vi: 'ቪ', va: 'ቫ', vie: 'ቬ', v: 'ቭ', vo: 'ቮ',
    S: 'ሽ', sh: 'ሽ', she: 'ሸ', shu: 'ሹ', shi: 'ሺ', sha: 'ሻ', shie: 'ሼ', sho: 'ሾ',
    ue: 'ው' // special case for convenience
};

// Sort keys by length descending to match longest prefixes first
const sortedKeys = Object.keys(geezMap).sort((a, b) => b.length - a.length);

export const transliterate = (text: string): string => {
    let result = '';
    let i = 0;

    while (i < text.length) {
        let matchFound = false;

        // Try to match from the current position with the longest keys first
        for (const key of sortedKeys) {
            if (text.startsWith(key, i)) {
                result += geezMap[key];
                i += key.length;
                matchFound = true;
                break;
            }
        }

        if (!matchFound) {
            result += text[i];
            i++;
        }
    }

    return result;
};

// A smarter transliteration that handles typing flows better
// Instead of re-processing the whole string every time which might mess up
// intentional edits or mixed content, this one is designed to be called
// on the current word or segment being typed if needed.
// However, for strict "transliterate as you type" in a controlled input,
// replacing the last typed characters is usually the strategy.

// Helper to detect if the last character typed should trigger a transformation
// This is more complex. A simpler approach for the requirements is:
// 1. Maintain the full Latin buffer? No, requirement says "transliterate as user types".
// 2. We need to detect patterns at the cursor.

export const applyTransliterationAtCursor = (
    currentValue: string,
    newValue: string,
    cursorPos: number
): { text: string; newCursorPos: number } => {
    // If deletion occurred (newValue is shorter), just accept it to avoid fighting backspace
    if (newValue.length < currentValue.length) {
        return { text: newValue, newCursorPos: cursorPos };
    }

    // Get the difference (the newly typed char)
    // This is a naive implementation; for robust IME-like behavior we often look back
    // a few characters from the cursor.

    // Let's look at the text *before* the cursor in the new value
    const textBeforeCursor = newValue.slice(0, cursorPos);

    // Find the last "word" or continuous segment of non-whitespace to operate on?
    // Or just look at the last few characters.
    // "sela" -> typed 'm' -> "selam" -> "ሰላም"

    // Strategy: Look at the suffix of textBeforeCursor that looks like a valid Latin composition key.
    // We need to find the longest suffix of textBeforeCursor that exists in our map OR
    // is a prefix of a key in our map.

    // ACTUALLY, the requirement is "Real time".
    // The simplest robust way for a web input is often:
    // Convert the *word* under the cursor from Latin logic to Ethiopic.
    // But users might want to edit.

    // Let's try a transformer that looks at the last few chars before cursor.
    // e.g. user typed "s", we leave "s". User types "e", "se" -> "ሰ".

    // We need a map that includes "partial" keys if we want to wait?
    // No, usually "s" maps to "ስ" (6th order) immediately.
    // Then "s" + "e" -> "ሰ" (1st order).

    // Let's refine the map for direct typing:
    // s -> ስ
    // ስ + e -> ሰ
    // ሰ + l -> ሰል
    // ሰል + a -> ሰላ
    // ...

    // This implies we need a way to "undo" the previous char if it merges.
    // Key mapping logic:
    // 1. If key is single consonant, map to 6th order (sadis).
    // 2. If key is vowel, look at previous char.
    //    - If previous char is 6th order consonant, combine to form new order.
    //    - If not, map to standalone vowel (alef/ayin base).

    return { text: newValue, newCursorPos: cursorPos }; // Placeholder for custom logic if we go that route
};

// For this specific feature request, a robust library approach is best.
// Using a "suffix replacement" strategy is common for Ethiopic IMEs.

export const getSymbol = (char: string): string | null => {
    return geezMap[char] || null;
}

export const isVowel = (char: string) => {
    return ['a', 'e', 'i', 'o', 'u'].includes(char.toLowerCase());
}
