As part of building a church management system and need to create a new  table to capture all member payments. Please help me design the table and implement the necessary code (assuming we're using a modern relational database PostgreSQL , but feel free to abstract it into a Sequelize if needed).

Key requirements:

1. **Transaction Types:**
   - Payments should be categorized as either:
     - Regular membership dues
     - Ad hoc contributions (e.g. special causes, events)

2. **Payment Methods:**
   - Must support and store the following methods:
     - Cash
     - Check (include check number and issuing bank if available)
     - Zelle
     - Credit/Debit card
     - ACH
     - Other electronic payments (include optional `paymentPlatform` field)

3. **Receipt Tracking:**
   - If payment was made by cash or check, the treasurer issues a receipt.
   - Receipt number must be stored in this case.

4. **Basic Fields:**
   - memberId (foreign key)
   - amount (decimal/money)
   - datePaid
   - paymentPurpose (enum or string: 'membership_dues', 'donation', etc.)
   - paymentMethod
   - receiptNumber (nullable; only required for check/cash)
   - notes (optional free text field)
   - receivedById (foreign key)

5. **Extra Considerations:**
   - Include createdAt, updatedAt timestamps
   - Make sure the structure is flexible for adding new payment methods or purposes
   - Consider indexing by memberId and datePaid for reporting queries

Please implement this as either:
- A SQL `CREATE TABLE` statement
- OR Sequelize model

Use best practices in naming, validation, and field types.

-- I want to refactor several PostgreSQL tables used in our church database. 
-- Our church is small (about 250 members), so I would like to use BIGINT instead of UUIDs for simplicity and better performance.

-- Please make the following schema updates:

-- 1. Rename the tables:
--    - Rename `church_transactions` to `transactions`
--    - Rename `dependants` to `dependents`

-- 2. Update the `transactions` table:
--    - Change `id` to BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
--    - Change `member_id` and `collected_by` to BIGINT, with foreign keys referencing `members(id)`

-- 3. Update the `members` table:
--    - Change `id` to BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
--    - Change `family_id` to BIGINT (nullable), referencing `members(id)` (for household relationships)

-- 4. Update the `dependents` table:
--    - Change `id` to BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
--    - Change `member_id` to BIGINT, referencing `members(id)`

-- 5. Ensure all existing foreign key relationships are updated appropriately.
-- 6. Make sure any indexes, constraints, and sequences are updated to match the new structure.
-- 7. Use `CASCADE` or other safe approaches where appropriate, but do not delete data.

-- Please output full SQL migration scripts for each table.



----------------------------------------------------------

-- Our PostgreSQL database is already in use with live data. We have the following tables:
-- - members (id UUID PK, family_id UUID FK)
-- - dependants (id UUID PK, member_id UUID FK)
-- - church_transactions (id UUID PK, member_id UUID FK, collected_by UUID FK)

-- We want to:
-- 1. Change all UUID-based primary and foreign keys in these three tables to BIGINT instead.
-- 2. Use `GENERATED BY DEFAULT AS IDENTITY` for primary keys.
-- 3. Rename the tables as follows:
--    - church_transactions -> transactions
--    - dependants -> dependents
-- 4. Migrate the data **without data loss** (ensure existing data is preserved correctly).

-- Please generate the SQL in a safe way using these steps:
-- - Create new tables with updated structure (BIGINT IDs + new names)
-- - Copy data over with correct ID mapping
-- - Drop constraints carefully and update referencing columns
-- - Rename the new tables to match desired names
-- - Optionally drop old tables after confirming successful migration
-- - Recreate any necessary indexes, constraints, or sequences

-- Ensure all steps are transaction-safe and preserve referential integrity.
-- Include comments to explain each part of the migration.

-- Target: PostgreSQL
-- Data volume is relatively small (~250 members), so performance is not a concern.
-- We want to avoid manually remapping IDs if possible.